//*****************************************************************************
//
// CPE 329-11
// Spring 2017
// Final Project - Visual Equalizer
//
// June 8, 2017
//
// Andrew Yoder
// Carlos Hernandez
//
//****************************************************************************

#include "msp.h"


void somi_init(void);
void equalizer_init(void);
void lcd_init(void);


void main(void)
{

    WDTCTL = WDTPW | WDTHOLD;           // Stop watchdog timer

    // Enable global interrupt
    __enable_irq();

    // Enable ADC interrupt in NVIC module
    NVIC->ISER[0] = 1 << ((ADC14_IRQn) & 31);

    // Sampling time, S&H=16, ADC14 on
    ADC14->CTL0 = ADC14_CTL0_SHT0_2 | ADC14_CTL0_SHP | ADC14_CTL0_ON | ADC14_CTL0_MSC | ADC14_CTL0_CONSEQ_2;
    ADC14->CTL1 = ADC14_CTL1_RES_2;         // Use sampling timer, 12-bit conversion results

    ADC14->MCTL[0] |= ADC14_MCTLN_INCH_1;   // A1 ADC input select; Vref=AVCC
    ADC14->IER0 |= ADC14_IER0_IE0;          // Enable ADC conv complete interrupt

    SCB->SCR &= ~SCB_SCR_SLEEPONEXIT_Msk;   // Wake up on exit from ISR

    // Start sampling/conversion
    ADC14->CTL0 |= ADC14_CTL0_ENC | ADC14_CTL0_SC;




    somi_init();
    equalizer_init();
    lcd_init();

}


void somi_init(void) {

    // disable for configuration
    EUSCI_B0->CTLW0 = EUSCI_B_CTLW0_SWRST;

    EUSCI_B0->CTLW0 = EUSCI_B_CTLW0_STEM |       // STE (P1.4) is enable signal
                      EUSCI_B_CTLW0_SYNC |       // synchronous mode for SPI
                      EUSCI_B_CTLW0_UCSSEL_2 |   // SMCLK
                      EUSCI_B_CTLW0_MST |        // master mode
                      EUSCI_B_CTLW0_SEVENBIT |   // 7-bit characters
                      EUSCI_B_CTLW0_MSB |        // MSB sent first
                      EUSCI_B_CTLW0_MODE_2;      // 4-pin SPI with STE low active

    // enable to receive/transmit data
    EUSCI_B0->CTLW0 &= ~EUSCI_B_CTLW0_SWRST;
}

void equalizer_init(void) {

    // MCLK from P4.3
    P4->DIR |= BIT3;
    P4->SEL1 &= ~BIT3;
    P4->SEL0 |= BIT3;

    // rst from P2.6
    P2->DIR |= BIT6;

    // vref from P5.6
    P5->SEL1 |= BIT6;
    P5->SEL0 |= BIT6;

    // analog out to P6.0
    P6->DIR &= ~BIT0;
    P6->SEL1 |= BIT0;
    P6->SEL0 |= BIT0;

    // strobe from TA0.2, P2.5
    P2->DIR |= BIT5;
    P2->SEL1 &= ~BIT5;
    P2->SEL0 |= BIT5;
}

void lcd_init(void) {

    // lcd_sce from P5.0
    P5->DIR |= BIT0;
    P5->OUT |= BIT0;   // active low, so set
    P5->SEL1 &= ~BIT0;
    P5->SEL0 &= ~BIT0;

    // lcd_rst from P2.4
    P2->DIR |= BIT4;
    P2->SEL1 &= ~BIT4;
    P2->SEL0 &= ~BIT4;

    // lcd_dc from P5.2
    P5->DIR |= BIT2;
    P5->OUT &= ~BIT2;   // command low, data high
    P5->SEL1 &= ~BIT2;
    P5->SEL0 &= ~BIT2;

    // sclk from P1.5
    // direction controlled by eUSCI_B0 module
    P1->SEL1 &= ~BIT5;
    P1->SEL0 |= BIT5;

    // SIMO from SOMI, P1.7
    // direction controlled by eUSCI_B0 module
    P1->SEL1 &= ~BIT7;
    P1->SEL0 |= BIT7;
}




// ADC14 interrupt service routine
void ADC14_IRQHandler(void) {
    
    ADC14->MEM[0]  = current;
}
