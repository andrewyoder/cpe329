To do list

measure voltage
-AC setting
-DC setting

frequency
-measure min and max
-if greater or equal than 0.5 diff then record time between max and min * 2 = period, f = 1/period.

integrate with console
-feq greater than 9600
-VT100 protocol, non changing field locations
-describe AC, DC, freq how it was recorded
-easy to read
-bargraphs for voltages being measured. Bar graph real-time monitored proportional lengths to voltages.





/**
 * Prioject 3
 *
 * Carlos Hernandez, Andrew Yoder
 * May 11, 2017
 */

#include "msp.h"
#define CYCLESPERMILL 1500
#define CONST_INCR 32

void delayMs(int n);
void UART0_init(void);

int total_area = 0;
int current_count = 0;
int max = 0;
int min = 0;
int period = 0;
unsigned int current_mode = 0;

void main(void)
{
    volatile unsigned int i;

    WDT_A->CTL = WDT_A_CTL_PW |             // Stop WDT
                 WDT_A_CTL_HOLD;




    // DCO = 48 MHz, MCLK = DCO, SMCLK = DCO / 16 = 3 MHz
  CS->KEY = CS_KEY_VAL;
  CS->CTL0 = 0;
  CS->CTL0 = CS_CTL0_DCORSEL_5;   // DCO = 48 MHz
  CS->CTL1 = CS_CTL1_SELA_2 | CS_CTL1_SELS_3 | CS_CTL1_SELM_3 | CS_CTL1_DIVHS_4;
  CS->KEY = 0;



  //timer1 setup for 48MHz
  TIMER_A0->CCTL[0] = TIMER_A_CCTLN_CCIE; // TACCR0 interrupt enabled
  TIMER_A0->CCR[0] = CONST_INCR;
  TIMER_A0->CTL = TIMER_A_CTL_SSEL__SMCLK | // SMCLK, continuous mode
            TIMER_A_CTL_MC__CONTINUOUS;

  //timer2 setup for 48MHZ
  TIMER_A1->CCTL[0] = TIMER_A_CCTLN_CCIE; // TACCR0 interrupt enabled
  TIMER_A1->CCR[0] = CONST_INCR;
  TIMER_A1->CTL = TIMER_A_CTL_SSEL__SMCLK | // SMCLK, continuous mode
            TIMER_A_CTL_MC__CONTINUOUS;

    // GPIO Setup
    P6->SEL1 |= BIT0;                       // Configure P6.0 for ADC
    P6->SEL0 |= BIT0;

    // Enable global interrupt
    __enable_irq();

    // Enable  interrupt in NVIC module
    NVIC->ISER[0] = 1 << ((TA0_0_IRQn) & 31);
    NVIC->ISER[0] = 1 << ((TA1_0_IRQn) & 31);


    // Sampling time, S&H=16, ADC14 on
    ADC14->CTL0 = ADC14_CTL0_SHT0_2 | ADC14_CTL0_SHP | ADC14_CTL0_ON | ADC14_CTL0_CONSEQ_2;
    ADC14->CTL1 = ADC14_CTL1_RES_3;         // Use sampling timer, 14-bit conversion results(16)

    ADC14->MCTL[0] |= ADC14_MCTLN_INCH_15;   // A15 ADC input select; Vref=AVCC
    //ADC14->IER0 |= ADC14_IER0_IE0;           Enable ADC conv complete interrupt

    SCB->SCR &= ~SCB_SCR_SLEEPONEXIT_Msk;   // Wake up on exit from ISR

    UART0_init();

    for (i = 20000; i > 0; i--);        // Delay

     // Start sampling/conversion
        ADC14->CTL0 |= ADC14_CTL0_ENC | ADC14_CTL0_SC;

    while (1)
    {

        if (current_count == CYCLESPERMILL)
        {
         current_count = 0;
         current_mode ++;

        }
    }
}


// Timer A0 interrupt service routine
void TA0_0_IRQHandler(void) {

    TIMER_A0->CCTL[0] &= ~TIMER_A_CCTLN_CCIFG;

    if (current_mode == 0)
    {
        if (ADC14->MEM[0] > max)
            max = ADC14->MEM[0];

        if (ADC14->MEM[0] < min)
            min = ADC14->MEM[0];

        current_count ++;
        TIMER_A0->CCR[0] += CONST_INCR;
    }
    else if (current_mode == 1)
    {
        total_area += ADC14->MEM[0];      // ADC12MEM0
        current_count ++;
        TIMER_A0->CCR[0] += CONST_INCR;
    }

}

// Timer A0 interrupt service routine
void TA1_0_IRQHandler(void) {

    TIMER_A1->CCTL[0] &= ~TIMER_A_CCTLN_CCIFG;



}



void UART0_init(void)
{
    EUSCI_A0->CTLW0 |= EUSCI_A_CTLW0_SWRST;
    EUSCI_A0->MCTLW &= ~EUSCI_A_MCTLW_OS16;
    EUSCI_A0->CTLW0 |= EUSCI_A_CTLW0_SSEL__SMCLK;
    EUSCI_A0->CTLW0 &= ~EUSCI_A_CTLW0_PEN;
    EUSCI_A0->BRW = 26;        // baud rate 115 200 bps
    P1->SEL0 |= 0x0C;
    P1->SEL1 &= ~0x0C;
    EUSCI_A0->CTLW0 &= ~1;
}

/* delay milliseconds */
void delayMs(int n) {

    int i, j;

    for (j = 0; j < n; j++)
        for (i = 300; i > 0; i--);      /* Delay 1 ms*/
}
