To do list

measure voltage
-AC setting
-DC setting

frequency
-measure min and max
-if greater or equal than 0.5 diff then record time between max and min * 2 = period, f = 1/period.

integrate with console
-feq greater than 9600
-VT100 protocol, non changing field locations
-describe AC, DC, freq how it was recorded
-easy to read
-bargraphs for voltages being measured. Bar graph real-time monitored proportional lengths to voltages.





/**
 * Prioject 3
 *
 * Carlos Hernandez, Andrew Yoder
 * May 11, 2017
 */

#include "msp.h"
#include <math.h>
#define CYCLESPERMILL 1500
#define CYCLESPERSEC 1500000
#define CONST_INCR 32

void delayMs(int n);
void UART0_init(void);

float total_area = 0;
float total_areasq = 0;
int current_count = 0;
int current_countms = 0;
float max = 0;
float min = 0;
int freq = -1;
float vDC = 0;
float vACt = 0;
float vACc = 0;
unsigned int f_mode = 0;

void main(void)
{
    volatile unsigned int i;
    float pk_pk = 0;
    float vACt2 = 0;
    int temp = 0;

    WDT_A->CTL = WDT_A_CTL_PW |             // Stop WDT
                 WDT_A_CTL_HOLD;




    // DCO = 48 MHz, MCLK = DCO = SMCLK
  CS->KEY = CS_KEY_VAL;
  CS->CTL0 = 0;
  CS->CTL0 = CS_CTL0_DCORSEL_5;   // DCO = 48 MHz
  CS->CTL1 = CS_CTL1_SELA_2 | CS_CTL1_SELS_3 | CS_CTL1_SELM_3;
  CS->KEY = 0;



  //timer0 setup for 48MHz
  TIMER_A0->CCTL[0] = TIMER_A_CCTLN_CCIE; // TACCR0 interrupt enabled
  TIMER_A0->CCR[0] = CONST_INCR;
  TIMER_A0->CTL = TIMER_A_CTL_SSEL__SMCLK | // SMCLK, continuous mode
            TIMER_A_CTL_MC__CONTINUOUS;

  //timer1 setup for 48MHz
    TIMER_A1->CCTL[0] = TIMER_A_CCTLN_CCIE; // TACCR0 interrupt enabled
    TIMER_A1->CCR[0] = CYCLESPERSEC;
    TIMER_A1->CTL = TIMER_A_CTL_SSEL__SMCLK | // SMCLK, continuous mode
              TIMER_A_CTL_MC__CONTINUOUS;

    //timer2 setup for 48MHz
      TIMER_A2->CCTL[0] = TIMER_A_CCTLN_CCIE; // TACCR0 interrupt enabled
      TIMER_A2->CCR[0] = CYCLESPERMILL;
      TIMER_A2->CTL = TIMER_A_CTL_SSEL__SMCLK | // SMCLK, continuous mode
                TIMER_A_CTL_MC__CONTINUOUS;




    // GPIO Setup
    P6->SEL1 |= BIT0;                       // Configure P6.0 for ADC
    P6->SEL0 |= BIT0;

    // Enable global interrupt
    __enable_irq();

    // Enable  interrupt in NVIC module
    NVIC->ISER[0] = 1 << ((TA0_0_IRQn) & 31);
    NVIC->ISER[0] = 1 << ((TA1_0_IRQn) & 31);
    NVIC->ISER[0] = 1 << ((TA2_0_IRQn) & 31);


    // Sampling time, S&H=16, ADC14 on
    ADC14->CTL0 = ADC14_CTL0_SHT0_2 | ADC14_CTL0_SHP | ADC14_CTL0_ON | ADC14_CTL0_CONSEQ_2;
    ADC14->CTL1 = ADC14_CTL1_RES_3;         // Use sampling timer, 14-bit conversion results(16)

    ADC14->MCTL[0] |= ADC14_MCTLN_INCH_15;   // A15 ADC input select; Vref=AVCC
    //ADC14->IER0 |= ADC14_IER0_IE0;           Enable ADC conv complete interrupt

    SCB->SCR &= ~SCB_SCR_SLEEPONEXIT_Msk;   // Wake up on exit from ISR

    UART0_init();

    for (i = 20000; i > 0; i--);        // Delay

     // Start sampling/conversion
        ADC14->CTL0 |= ADC14_CTL0_ENC | ADC14_CTL0_SC;

    while (1)
    {
        pk_pk = max - min;

        if (pk_pk >= 0.5)
        {
            //AC
            while (!(EUSCI_A0->IFG & 0x02)){}
            EUSCI_A0->TXBUF = 0x1B[2J; //clear
            while (!(EUSCI_A0->IFG & 0x02)){}
            EUSCI_A0->TXBUF = 0x1B[H; // cursor home
            Esc[2J
            vACt2 = sqrt(vACt);
            vACc = vACt2 - vDC;
            send_voltage(vACt2*1000);
            while (!(EUSCI_A0->IFG & 0x02)){}
            EUSCI_A0->TXBUF = ' ';
            send_voltage(vACc*1000);
            while (!(EUSCI_A0->IFG & 0x02)){}
            EUSCI_A0->TXBUF = ' ';
            send_voltage(freq*1000);
        }
        else
        {
            send_voltage(vDC*1000);

            vDC
        }



    }
}

/*
 *
 * Esc[ValueA   Move cursor up n lines  CUU
Esc[ValueB  Move cursor down n lines    CUD
Esc[ValueC  Move cursor right n lines   CUF
Esc[ValueD  Move cursor left n lines    CUB
 *
 *
 */



void send_voltage(int curr_vol)
{
    while (!(EUSCI_A0->IFG & 0x02)){}
       EUSCI_A0->TXBUF = curr_vol / 1000 + 0x30;          // ones
       while (!(EUSCI_A0->IFG & 0x02)){}
       EUSCI_A0->TXBUF = '.';
       while (!(EUSCI_A0->IFG & 0x02)){}
       EUSCI_A0->TXBUF = (curr_vol % 1000) / 100 + 0x30;   // tenths
       while (!(EUSCI_A0->IFG & 0x02)){}
       EUSCI_A0->TXBUF = (curr_vol % 100) /10  + 0x30 ;  // hundredths
       while (!(EUSCI_A0->IFG & 0x02)){}
       EUSCI_A0->TXBUF = (curr_vol % 10)  + 0x30 ;  // thousands

}


// Timer A0 interrupt service routine
void TA0_0_IRQHandler(void) {
    float curr = 0;

    TIMER_A0->CCTL[0] &= ~TIMER_A_CCTLN_CCIFG;
    curr = (ADC14->MEM[0]) / 5000;

    total_area += curr;
    total_areasq += curr*curr;
    current_count ++;
    current_countms ++;

    if (curr > max)
        max = curr;

    if (curr < min)
        min = curr;

    if (f_mode == 0 && curr > max - .005)
    {
        f_mode ++;
        freq ++;
    }
    else if (f_mode == 1 && curr < min + .005)
    {
        f_mode = 0;
    }

    TIMER_A0->CCR[0] += CONST_INCR;
}


void TA1_0_IRQHandler(void) {

    TIMER_A1->CCTL[0] &= ~TIMER_A_CCTLN_CCIFG;

    vACt = total_areasq/current_count;
    current_countms = 0;
    total_areasq = 0;


    TIMER_A1->CCR[0] += CYCLESPERSEC;
}

void TA2_0_IRQHandler(void) {

    TIMER_A2->CCTL[0] &= ~TIMER_A_CCTLN_CCIFG;

    vDC = total_area/current_countms;
    current_countms = 0;
    total_area = 0;

    TIMER_A2->CCR[0] += CYCLESPERMILL;
}




void UART0_init(void)
{
    EUSCI_A0->CTLW0 |= EUSCI_A_CTLW0_SWRST;
    EUSCI_A0->MCTLW &= ~EUSCI_A_MCTLW_OS16;
    EUSCI_A0->CTLW0 |= EUSCI_A_CTLW0_SSEL__SMCLK;
    EUSCI_A0->CTLW0 &= ~EUSCI_A_CTLW0_PEN;
    EUSCI_A0->CTLW0 &= ~EUSCI_A_CTLW0_SEVENBIT;
    EUSCI_A0->CTLW0 &= ~EUSCI_A_CTLW0_SPB;
    EUSCI_A0->BRW = 417;        // baud rate 115 200 bps (48 000 000 / 115 200)
    P1->SEL0 |= 0x0C;
    P1->SEL1 &= ~0x0C;
    EUSCI_A0->CTLW0 &= ~EUSCI_A_CTLW0_SWRST;
}



